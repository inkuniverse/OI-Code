# Want to join us? Try clone!

`git clone https://github.com/inkuniverse/OI-code`

1. 尝试检查变量，交换变量
1. 看清求什么
1. 01背包倒着枚举，看清v,w
1. 一定要看**数据范围**
1. dp的max,min要看好
1. ~~看与标答相差几，找对应debug~~
1. 下标从1开始！ ~~（特殊题除外)~~
1. 多数据注意换行
1. 无限扩展注意模坐标和原坐标
1. 差分要开第二个数组(否则会出现奇奇怪怪的问题)
1. 要bfs时看清数据范围，若超时，尝试双向bfs,但是可以bfs两遍，而不是压入两个~~差不多吧~~
1. 单层图解决不了，试试多层图。

### 强联通
1. 对于一些存在依赖关系的模型，若其建图是一个DAG，则可以直接通过拓扑排序解决，但若其中有环则需要特殊处理
1. 对于有环的问题，会出现一些互相依赖的关系，这些关系组成了一个强连通分量，根据题目要求的性质，对于这个强连通分量可以将其缩为一个点
1. 将所有强连通分量缩成点后即可在DAG上求解
1. 建模方式和DAG很相似，建出图不是DAG就先跑一边SCC缩点即可1. 数学题要特判哦
1. A边终点未访问过，为树枝边
1. B边终点已被访问过，且$dfn[v]>dfn[u]$，说明在子树中，说明为前向边
1. C边终点已被访问过且不在子树中，终点在栈中则为后向边
1. D边终点已被访问过且不在子树中且已经出栈，为横叉边
### 双联通
1. 点双连通：删去任何一个点仍然连通
1. 边双连通：删去任何一条边仍然连通
1. 另一种定义是，任何两点之间至少存在两条不经过相同中间点（边）的路径
1. 割点: low[v]>=dfn[u]
2. 割边：low[v]>dfn[u]